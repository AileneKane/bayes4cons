---
title: "Case Study 1"
format: pdf
editor: visual
fig_width: 16 
fig_height: 12 
---

\emph{This case study was developed primarily by E.Wolkovich, D.Loughnan and X.Wang with the input of the full manuscript author team.}

```{r include=FALSE}
simulate_population <- function(a, b, t, noise_sd) {
  y <- numeric(t)
  time <- 1:t
  y <- a*time + b + rnorm(t, 0, noise_sd)
    # y is the population at a certain time
    # a is the increasing/decreasing rate
    # b is the starting population size
    # time is the x variable 
    # noise_sd
  model <- lm(y ~ time)
  # Extract the estimated slope (coefficient of time)
  estimated_slope <- coef(model)["time"]
  pval <- coef(summary(lm(y ~ time)))[["time", "Pr(>|t|)"]]
  return(c(estimated_slope, pval))
}
t <- 10
a <- seq(from = -2000, to = 2000, by = 200)
b <- 100000
noise_sd <- seq(from = 1000, to = 10000, by = 400)

dfout <- data.frame(givenslope = numeric(), noise = numeric(), estslope = numeric(), 
                    pval = numeric())

for (i in 1:length(a)) {
  for (j in 1:length(noise_sd)){
    simpopout <- simulate_population(a[i], b, t, noise_sd[j])
    dfadd <- data.frame(givenslope = a[i], noise = noise_sd[j], 
                        estslope = simpopout[1], pval = simpopout[2])
    dfout <- rbind(dfout, dfadd)
  }
}
```

```{r include=FALSE}
a <- seq(from = -2000, to = 2000, by = 200)
a <- a[-c(5:17)] 
# remove middle close-to-zero slopes, as though are hard to get pval low
noise_sd <- seq(from = 7000, to = 9000, by = 400) 
srhere <- 0.3

for(seedz in c(333:3999)){
  set.seed(seedz)
  for (j in 1:length(noise_sd)){
    dfout <- data.frame(noise = numeric(), sloperatio = numeric(), pval = numeric(),
                        smratio = numeric())
    for (i in 1:length(a)) {
      simpopout <- simulate_population(a[i], b, t, noise_sd[j])
      smratiohere  <- ifelse((abs(simpopout[1]/a[i])<(1+srhere) 
                              & abs(simpopout[1]/a[i])>(1-srhere)), 0, 1)
      dfadd <- data.frame(noise = noise_sd[j], sloperatio = simpopout[1]/a[i], 
                          pval = simpopout[2], smratio = smratiohere)
      dfout <- rbind(dfout, dfadd)
    }
      if(sum(dfout$smratio) == 0 & dfout$pval[1] > 0.05 & dfout$pval[1] < 0.15){
    print(paste("try seed: ", seedz, "with noise of ", noise_sd[j]))
  }
  }
}
```

```{r include=FALSE}
set.seed(1546)
t <- 10
b <- 100000
noise_sd <- rev(seq(from = 3000, to = 8600, by = 400))

dfout <- data.frame(givenslope = numeric(), noise = numeric(), estslope = numeric(), pval = numeric())

for (i in 1:length(a)) {
    simpopout <- simulate_population(a[i], b, t, noise_sd[i])
    dfadd <- data.frame(givenslope = a[i], noise = noise_sd[i], estslope = simpopout[1], pval = simpopout[2])
    dfout <- rbind(dfout, dfadd)
}

dfout
```

# Data analysis

The following code performs data analysis and visualization using both the traditional Fisherian approach and the Bayesian approach. For the Fisherian approach, we use an `lm` model and plot the p-values for different populations, indicating whether the increase or decrease is statistically significant. For the Bayesian approach, we use Stan code with priors and plot the posterior distribution.

```{r include = FALSE}
# Use 4 cores
options(mc.cores = 4)

# Install dependencies
require(rstan)
require(lme4)
require(shinystan)
require(viridis)
```

```{r}
# Seed we selected from data simulation
set.seed(1546)
# Dropping -1600, 1600 with p-value smaller than 0.05.
a <- c(-2000, -1600, -1400,  600, 1400 , 1600,  2000)
t <- 10
time <- 1:t
b <- seq(40000, 101000, by = 10000)
noise_sd <- c(7000, 6600, 6200, 5800, 5400, 5000,4600)
```

## Traditional Fisherian approach

With traditional Fisherian approach, we use lm model to plot

```{r}

output <- data.frame(iter = seq(1:(length(a)*length(time))), 
                     pop = rep(1:length(a), each = length(time)), 
                     year = rep(1:t, times = length(a)))
output$pred <- NA  

abund <- vector()
for(i in 1:length(a)){
  y <- numeric(t)
  time <- 1:t
  y <- a[i]*time + b[i] + rnorm(t, 0, noise_sd[i])
  abund <- rbind(abund, y)
}

abund <- data.frame(reshape2::melt(t(abund)))
output$pred <- abund$value
```

### Visualization

```{r include=FALSE}
# Set color palette for plots
popID <- unique(output$pop)
colors <- c("#f7cb44ff", "#f68f46ff", "#de7065ff", "#a65c85ff","#593d9cff","purple4", "navy")

par(mfrow = c(1, 1), mar = c(5.1, 4.5, 4.1, 2.1))
# Abundance over time with regression lines
marks <- c(0, expression('5e'^4*''), expression('1e'^5*''), expression('1.4e'^5*''))
ticks <- c(0, 50000, 100000, 150000)

plot(1, type = "n", ylab = "Abundance", xlab = "Year", xlim = c(0, 11), ylim = c(0, 250000), 
     cex.lab = 1.5, frame.plot = FALSE, xaxs = "i", yaxs = "i", yaxt = "n")

# Customize axes
axis(side = 1, at = seq(-3000, 3000, by = 1), cex.axis = 1)
axis(side = 2, at = ticks, labels = marks, cex.axis = 1)

# Plot data points for each population
for(i in 1:length(unique(output$pop))) {
  temp <- subset(output, pop == popID[i])
  points(temp$year, temp$pred, col = colors[i], pch = 19)
}

# Add regression lines for selected populations
abline(lm(pred ~ year, subset(output, pop == popID[5])), lty = 4, col = colors[5], lwd = 1.5)
abline(lm(pred ~ year, subset(output, pop == popID[4])), lty = 4, col = colors[4], lwd = 1.5)

# Add legend
legend("topright", legend = c(expression('Farthest north (p = 3.4e'^-4*')'),
                              expression('North (p = 0.01)'),
                              expression('Middle (p = 0.36)'),
                              expression('South (p = 0.15)'),
                              expression('Farthest south (p = 0.08)')),
       lty = c(1, 1, 1, 1, 1), lwd = 4, bty = "n", col = c("#593d9cff","#a65c85ff", "#de7065ff", "#f68f46ff","#f7cb44ff"),cex = 1, pt.cex = 2.5)
```

![](frequentist.png){fig-align="center"}

## Bayesian approach

With Bayesian approach, we run the stan code:

```{r engine = 'cat', engine.opts = list(file = "partialPoolSimMdl.stan", lang = "stan")}
data {
  int<lower=0> N; //No. obs
  int<lower=0> Ngrp; //No. in group---population or species
  int group[N]; // Group type
  vector[N] year;
  real ypred[N]; //response
}

parameters {
  real a[Ngrp] ;
  real b[Ngrp]; 
  real mu_a; 
  real<lower=0> sigma_a;
  real mu_b; 
  real<lower=0> sigma_b; 
  real<lower=0> sigma_y; 
  
}

model {

real mu_y[N]; 

for(i in 1:N){
     mu_y[i] = a[group[i]] + b[group[i]] * year[i];
  }
  
a ~ normal(mu_a, sigma_a);
b ~ normal(mu_b, sigma_b);

//Priors
mu_a ~ normal(188, 50); 
sigma_a ~ normal(0,50);
mu_b ~ normal(0,10); 
sigma_b ~ normal(0,10); 
sigma_y ~ normal(0,10); 

ypred ~ normal(mu_y, sigma_y);
}

```

```{r echo = FALSE}
output <- subset(output, pop != 2 & pop != 6)
str(output)
output$pop <- as.factor(output$pop)

datalistGrp <- with(output,
                    list( N = nrow(output),
                          Ngrp = length(unique(output$pop)),
                          group = as.numeric(as.factor(output$pop)),
                          ypred = output$pred,
                          year = output$year ))
```

```{r message = FALSE}
mdlPop <- stan("partialPoolSimMdl.stan",
               data = datalistGrp)

sum <- summary(mdlPop)$summary

intercept <- sum[grep("a\\[", rownames(sum)), "mean"]
slopes <- sum[grep("b\\[", rownames(sum)), "mean"]

# Posterior distribution
post <- rstan::extract(mdlPop)
```

### Visualization

```{r echo = FALSE}

par(mfrow = c(1, 1), mar = c(5.1, 4.5, 4.1, 2.1))

# Histogram of change in abundance with uncertainty intervals
plot(1, type = "n", xlab = "Change in abundance", ylab = "Frequency", xlim = c(-2500, 2500), ylim = c(0, 1500), cex.lab = 1.5, frame.plot = FALSE)

# Plot histograms for each population's posterior distribution
for(i in 1:length(unique(output$pop))) {
  hist(post$b[,i], add = TRUE, col = colors[i])
  axis(side = 1, at = seq(-3000, 3000, by = 1000), cex.axis = 1)
  axis(side = 2, at = seq(-1000000, 1000000, by = 1000), cex.axis = 1)

# Add mean and uncertainty intervals
  points(x = mean(post$b[,i]), y = 1300, col = colors[i], pch = 19)
  arrows(x0 = (quantile(post$b[,i], 0.05)), y0 = 1300, x1 = (quantile(post$b[,i], 0.95)), y1 = 1300, code = 3, length = 0, col = colors[i], lwd = 2)
}
```
