legend("topright",lty=1,lwd=3,col=c("darkgreen","lightgreen"), legend=c("Flux uncertainty","Area uncertainty"), bty="n")
plot(x,ch4meds,
type="p", pch=16, cex=1,col="darkgreen",
ylim=c(-1,250),xlim=c(.5,2.5),xaxt='n',cex.axis=2,
ylab="CH4 (kg per ha per yr)",xlab="Land Use",cex.lab=2,
main="CH4 Emissions in Project Area",
bty="l")
for(i in 1:length(x)){
arrows(x[i],uncert[1,i],x[i],uncert[2,i],
code=3, angle=90, length=0.05,lwd=2, col="darkgreen")
}
for(i in 1:length(x)){
arrows(x[i],uncert_extmin[1,i],x[i],uncert_extmax[2,i],
code=3, angle=90, length=0.05,lwd=2, col="lightgreen")
}
axis(1,at=x,labels=c("grazed","ungrazed"), cex.axis=2)
points(x,ch4meds,pch=16, cex=2.5,col="darkgreen",)
legend("topright",lty=1,lwd=3,col=c("darkgreen","lightgreen"), legend=c("Flux uncertainty","Area uncertainty"), bty="n")
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
getwd()
setwd("~/GitHub/bayes4cons"
)
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
plot(x,ch4meds,
type="p", pch=16, cex=1,col="darkgreen",
ylim=c(-1,250),xlim=c(.5,2.5),xaxt='n',cex.axis=2,
ylab="CH4 (kg per ha per yr)",xlab="Land Use",cex.lab=2,
main="CH4 Emissions in Project Area",
bty="l")
for(i in 1:length(x)){
arrows(x[i],uncert[1,i],x[i],uncert[2,i],
code=3, angle=90, length=0.05,lwd=2, col="darkgreen")
}
for(i in 1:length(x)){
arrows(x[i],uncert_extmin[1,i],x[i],uncert_extmax[2,i],
code=3, angle=90, length=0.05,lwd=2, col="lightgreen")
}
axis(1,at=x,labels=c("grazed","ungrazed"), cex.axis=2)
points(x,ch4meds,pch=16, cex=2.5,col="darkgreen",)
legend("topright",lty=1,lwd=3,col=c("darkgreen","lightgreen"), legend=c("Flux uncertainty","Area uncertainty"), bty="n")
dev.off()
install.packages("rstan")
knitr::opts_chunk$set(echo = TRUE)
sessionInfo()
exp(-7)
exp(7)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(bayesplot)
library(ggplot2)
# To run in parallel on multiple cores
options(mc.cores=parallel::detectCores())
# To avoid recompiling unchanged Stan program
rstan_options(auto_write=TRUE)
# Create a vector that will keep track of the states
# It's of length T + 1 (+1 for t=0)
TT <- 20
z <- numeric(TT + 1)
# Population starts at 20 (number of individual re-introduced)
z[1] <- 20
# Standard deviation of the process variation
sdo <- 10
sdp <- 0.05
beta0 <- log(1.3)
beta1 <- -0.005
# Set the seed, so we can reproduce the results
set.seed(87687)
# For-loop that simulates the state through time, using i instead of t,
for(i in 1:TT){
# This is the process equation
z[i+1] <- z[i]*exp(beta0 + beta1*z[i] + rnorm(1, 0, sdp))
# Note that this index is shifted compared to equation in text,
# because we assume the first value to be at time 0
}
# Create a vector that will keep track of the observations
# It's of length T
y <- numeric(TT)
# Standard deviation of the observation error
# For t=1, ... T, add measurement error
# Remember that z[1] is t=0
y <- z[2:(TT+1)] + rnorm(TT, 0, sdo)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col="hotpink") +
geom_point(data = monitoring, aes(y= obs, x = year), col="grey") +
ylab("Population")
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col="hotpink") +
geom_point(data = monitoring, aes(y= obs, x = year), col="grey") +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col="hotpink") +
geom_point(data = monitoring, aes(y= obs, x = year), col=grey(0.1)) +
ylab("Population/count") +
theme_bw()
# Colours for plots
col_ts <- c("hotpink", grey(0.2)) # Real pop. traj, observed pop. traj.
# Colours for plots
col_real <- "hotpink" # Real population trajectory
col_obs <- grey(0.2) # Observed population trajectory
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col = "real") +
geom_point(data = monitoring, aes(y= obs, x = year), col = "obs") +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), colour = "real") +
geom_point(data = monitoring, aes(y= obs, x = year), colour = "obs") +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), colour = "real") +
geom_point(data = monitoring, aes(y= obs, x = year), colour = "obs") +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year, colour = "real")) +
geom_point(data = monitoring, aes(y= obs, x = year, colour = "obs")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year, colour = "real")) +
geom_point(data = monitoring, aes(y= obs, x = year, colour = "obs")) +
scale_color_manual(name = "Pop. trajctories",
values = c("real" = col_real, "obs" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year, colour = "Real")) +
geom_point(data = monitoring, aes(y= obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(bayesplot)
library(ggplot2)
# To run in parallel on multiple cores
options(mc.cores=parallel::detectCores())
# To avoid recompiling unchanged Stan program
rstan_options(auto_write=TRUE)
# Colours for plots
col_real <- "hotpink" # Real population trajectory
col_obs <- grey(0.2) # Observed population trajectory
# Create a vector that will keep track of the states
# It's of length T + 1 (+1 for t=0)
TT <- 20
z <- numeric(TT + 1)
# Population starts at 20 (number of individual re-introduced)
z[1] <- 20
# Standard deviation of the process variation
sdo <- 10
sdp <- 0.05
beta0 <- log(1.3)
beta1 <- -0.005
# Set the seed, so we can reproduce the results
set.seed(87687)
# For-loop that simulates the state through time, using i instead of t,
for(i in 1:TT){
# This is the process equation
z[i+1] <- z[i]*exp(beta0 + beta1*z[i] + rnorm(1, 0, sdp))
# Note that this index is shifted compared to equation in text,
# because we assume the first value to be at time 0
}
# Create a vector that will keep track of the observations
# It's of length T
y <- numeric(TT)
# Standard deviation of the observation error
# For t=1, ... T, add measurement error
# Remember that z[1] is t=0
y <- z[2:(TT+1)] + rnorm(TT, 0, sdo)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
dataStan <- list(y=y, TT=TT, w0=log(z[1]))
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
exp(0.05)
exp(0.07)
exp(-0.05)
z[1]
dataStan <- list(y = y, TT = TT,
w0 = log(z[1]), # Starting population, 20 (number re-introduce)
sd0 = 0.0001) # Low sd for the first time step
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
exp(log(0.05))
exp(-log(0.05))
exp(log(-0.05))
exp(log(0.05))
exp(0.05)
exp(-0.05)
exp(-0.10)
exp(0.10)
exp(0.25)
exp(-0.25)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
control=list(adapt_delta=0.9)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
pairs()
pairs(m.biol.informed)
control=list(adapt_delta = 0.99)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
control=list(adapt_delta = 0.99)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 100000, seed= "123")
knitr::opts_chunk$set(echo = TRUE)
m.informed.post <- as.matrix(m.biol.informed)
sdo.est.informed <- m.informed.post[,"sdo"]
sdp.est.informed <- m.informed.post[,"sdp"]
beta0.est.informed <- m.informed.post[,"beta0"]
beta1.est.informed <- m.informed.post[,"beta1"]
# True pop. estimates
pop.est.informed <- exp(rstan::extract(m.biol.informed, pars = "w")[[1]])
pop.est.informed.sum <- data.frame(year= seq(2024-TT, length.out = TT),
pop.mean = colMeans(pop.est.informed),
t(apply(pop.est.informed, 2, quantile, probs=c(0.025, 0.975))))
colnames(pop.est.informed.sum)[3:4] <- c("lower", "upper")
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(bayesplot)
library(ggplot2)
# To run in parallel on multiple cores
options(mc.cores=parallel::detectCores())
# To avoid recompiling unchanged Stan program
rstan_options(auto_write=TRUE)
# Colours for plots
col_real <- "purple" # Real population trajectory
col_obs <- grey(0.2) # Observed population trajectory
col_real_est <- "hotpink"
# Create a vector that will keep track of the states
# It's of length T + 1 (+1 for t=0)
TT <- 20
z <- numeric(TT + 1)
# Population starts at 20 (number of individual re-introduced)
z[1] <- 20
# Standard deviation of the process variation
sdo <- 10
sdp <- 0.05
beta0 <- log(1.3)
beta1 <- -0.005
# Set the seed, so we can reproduce the results
set.seed(87687)
# For-loop that simulates the state through time, using i instead of t,
for(i in 1:TT){
# This is the process equation
z[i+1] <- z[i]*exp(beta0 + beta1*z[i] + rnorm(1, 0, sdp))
# Note that this index is shifted compared to equation in text,
# because we assume the first value to be at time 0
}
# Create a vector that will keep track of the observations
# It's of length T
y <- numeric(TT)
# Standard deviation of the observation error
# For t=1, ... T, add measurement error
# Remember that z[1] is t=0
y <- z[2:(TT+1)] + rnorm(TT, 0, sdo)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
dataStan <- list(y = y, TT = TT,
w0 = log(z[1]), # Starting population, 20 (number re-introduce)
sd0 = 0.0001) # Low sd for the first time step
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
traceplot(m.vague, pars=c("sdo", "sdp", "beta1", "beta0"))
# Posterior
m.vague.post <- as.matrix(m.vague)
sdo.est.vague <- m.vague.post[,"sdo"]
sdp.est.vague <- m.vague.post[,"sdp"]
beta0.est.vague <- m.vague.post[,"beta0"]
beta1.est.vague <- m.vague.post[,"beta1"]
m.sim.informed <- stan(file = "ssm_dens_sim_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
traceplot(m.sim.informed, pars=c("sdo", "sdp", "beta1", "beta0"))
m.sim.informed.post <- as.matrix(m.sim.informed)
sdo.est.sim.informed <- m.sim.informed.post[,"sdo"]
sdp.est.sim.informed <- m.sim.informed.post[,"sdp"]
beta0.est.sim.informed <- m.sim.informed.post[,"beta0"]
beta1.est.sim.informed <- m.sim.informed.post[,"beta1"]
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
traceplot(m.biol.informed, pars=c("sdo", "sdp", "beta1", "beta0"))
m.informed.post <- as.matrix(m.biol.informed)
sdo.est.informed <- m.informed.post[,"sdo"]
sdp.est.informed <- m.informed.post[,"sdp"]
beta0.est.informed <- m.informed.post[,"beta0"]
beta1.est.informed <- m.informed.post[,"beta1"]
# True pop. estimates
pop.est.informed <- exp(rstan::extract(m.biol.informed, pars = "w")[[1]])
pop.est.informed.sum <- data.frame(year= seq(2024-TT, length.out = TT),
pop.mean = colMeans(pop.est.informed),
t(apply(pop.est.informed, 2, quantile, probs=c(0.025, 0.975))))
colnames(pop.est.informed.sum)[3:4] <- c("lower", "upper")
pop.est.informed.sum
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_point(data = pop.est.informed.sum, aes(x=year, y=pop.mean, colour = "Estimated")) +
geom_ribbon(data = pop.est.informed.sum, aes(ymin = lower, ymax = upper),
fill= alpha(col_real_est, 0.5)) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real,
"Observed" = col_obs,
"Estimated" = col_real_est)) +
ylab("Population/count") +
theme_bw()
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_point(data = pop.est.informed.sum, aes(x=year, y=pop.mean, colour = "Estimated")) +
geom_ribbon(data = pop.est.informed.sum, aes(ymin = lower, ymax = upper)) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real,
"Observed" = col_obs,
"Estimated" = col_real_est)) +
ylab("Population/count") +
theme_bw()
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_point(data = pop.est.informed.sum, aes(x=year, y=pop.mean, colour = "Estimated")) +
geom_ribbon(data = pop.est.informed.sum, aes(x=year, y=pop.mean, ymin = lower, ymax = upper),
fill= alpha(col_real_est, 0.5)) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real,
"Observed" = col_obs,
"Estimated" = col_real_est)) +
ylab("Population/count") +
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(bayesplot)
library(ggplot2)
# To run in parallel on multiple cores
options(mc.cores=parallel::detectCores())
# To avoid recompiling unchanged Stan program
rstan_options(auto_write=TRUE)
# Colours for plots
col_real <- "purple" # Real population trajectory
col_obs <- grey(0.2) # Observed population trajectory
col_real_est <- "hotpink"
# Create a vector that will keep track of the states
# It's of length T + 1 (+1 for t=0)
TT <- 20
z <- numeric(TT + 1)
# Population starts at 20 (number of individual re-introduced)
z[1] <- 20
# Standard deviation of the process variation
sdo <- 10
sdp <- 0.05
beta0 <- log(1.3)
beta1 <- -0.005
# Set the seed, so we can reproduce the results
set.seed(87687)
# For-loop that simulates the state through time, using i instead of t,
for(i in 1:TT){
# This is the process equation
z[i+1] <- z[i]*exp(beta0 + beta1*z[i] + rnorm(1, 0, sdp))
# Note that this index is shifted compared to equation in text,
# because we assume the first value to be at time 0
}
# Create a vector that will keep track of the observations
# It's of length T
y <- numeric(TT)
# Standard deviation of the observation error
# For t=1, ... T, add measurement error
# Remember that z[1] is t=0
y <- z[2:(TT+1)] + rnorm(TT, 0, sdo)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
dataStan <- list(y = y, TT = TT,
w0 = log(z[1])) # Starting population, 20 (number re-introduce)
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(bayesplot)
library(ggplot2)
# To run in parallel on multiple cores
options(mc.cores=parallel::detectCores())
# To avoid recompiling unchanged Stan program
rstan_options(auto_write=TRUE)
# Colours for plots
col_real <- "purple" # Real population trajectory
col_obs <- grey(0.2) # Observed population trajectory
col_real_est <- "hotpink"
# Create a vector that will keep track of the states
# It's of length T + 1 (+1 for t=0)
TT <- 20
z <- numeric(TT + 1)
# Population starts at 20 (number of individual re-introduced)
z[1] <- 20
# Standard deviation of the process variation
sdo <- 10
sdp <- 0.05
beta0 <- log(1.3)
beta1 <- -0.005
# Set the seed, so we can reproduce the results
set.seed(87687)
# For-loop that simulates the state through time, using i instead of t,
for(i in 1:TT){
# This is the process equation
z[i+1] <- z[i]*exp(beta0 + beta1*z[i] + rnorm(1, 0, sdp))
# Note that this index is shifted compared to equation in text,
# because we assume the first value to be at time 0
}
# Create a vector that will keep track of the observations
# It's of length T
y <- numeric(TT)
# Standard deviation of the observation error
# For t=1, ... T, add measurement error
# Remember that z[1] is t=0
y <- z[2:(TT+1)] + rnorm(TT, 0, sdo)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
dataStan <- list(y = y, TT = TT,
w0 = log(z[1])) # Starting population, 20 (number re-introduce)
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
