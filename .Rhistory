annual_jul_156499_jul,
annual_jul_167065_jul,
annual_jul_167413_jul,
annual_jul_171177_jul,
annual_PA_171217_jul,
annual_PA_173501_jul,
annual_PA_174613_jul,
annual_PA_17663_jul,
annual_PA_183851_jul,
annual_PA_183853_jul,
annual_PA_183863_jul,
annual_PA_183883_jul,
annual_PA_185377_jul,
annual_PA_190605_jul,
annual_PA_192199_jul,
annual_PA_194473_jul,
annual_PA_7384_jul,
annual_PA_9732_jul,
annual_PA_50485_jul,
annual_PA_51969_jul,
annual_PA_94745_jul,
annual_PA_98105_jul
)
sensor_ids <- c(
"136172", "15203", "156499", "167065", "167413", "171177",
"171217", "173501", "174613", "17663", "183851", "183853",
"183863", "183883", "185377", "190605", "192199", "194473",
"7384", "9732", "50485", "51969", "94745", "98105"
)
annual_data <- data.frame(
sensor = sensor_ids, annual = values)
PM2.5_EPA_annual <- data.frame(yintercept = 9, Lines = 'Annual') # long-term standard (annual average)
annual <- ggplot(annual_data, aes(x=sensor, y=annual))+
geom_point()+
theme(axis.text.x = element_text(angle = 45, hjust = 1))+
geom_hline(data = PM2.5_EPA_annual, aes(yintercept = yintercept,
color = "Annual Standard", linetype = "Annual"), linetype = "dashed")+
scale_color_manual(values = c("Annual Standard" = "red"),
labels = c("Annual Standard" = "9 Âµg/m3")) +
labs(color = "EPA Annual Standard", x="Sensor",
y = "# of Measurements Exceeding Standard")+
ggtitle("Purple Air (PA) Sensors and Number of Readings Exceeding EPA Standard July 2024",
subtitle = "30 Minute Averaging Period Readings")+
theme(legend.position = c(0.89, 0.89))
annual
y
x
#clear workspace
rm(list=ls())
#set strings default and avoid scientific notation for 6 digits
options(stringsAsFactors = FALSE, "scipen"=1000, "digits"=6)
library(dplyr)
library(lme4)
library(ggplot2)
library(car)
require(gridExtra)
library(RColorBrewer)
library(sf)
library(sp)
library(tidyverse)
library(ggpubr)#used in Locke et al 2020
library(sjPlot)
library(sjstats)
library(knitr)
#library(rgdal)  # for vector work; sp package should always load with rgdal.
library(raster)
library(sp)
library(maps)
library(mapdata)
library(tigris)
options(tigris_use_cache = TRUE)
setwd("/Users/samiebaclig/Documents/GitHub/grit")
#Read in lat/longs of air quality monitors
#(need to creat this file first based on the loggers chosen frmo PurpleAir Map)
locs<-read.csv("data/PurpleAir/ALL_PA_locs.csv", header=TRUE)
setwd("~/GitHub/grit")
#Read in lat/longs of air quality monitors
#(need to creat this file first based on the loggers chosen frmo PurpleAir Map)
locs<-read.csv("data/PurpleAir/ALL_PA_locs.csv", header=TRUE)
#correct mistake in locs
locs$longitude[locs$longitude==122.517100000000]<- -122.517100000000
locs_raw <-rename(locs)#, Longitude = x, Latitude = y)
#read in Puget Sound landcover layer from stormwater heat map (https://tnc.app.box.com/s/rephyio647qxpy44uuvaspkq8p8h4yfu)
lc <-
raster("~/Documents/Land Cover/psLandCover_mosaic.tif")
lcNOAA <-
raster("~/Documents/Land Cover/wa_2021_ccap_v2_hires_canopy_20240402.tif")
lcNOAA <-  raster("data/C-CAP/wa_2021_ccap_v2_hires_canopy_20240402.tif")
lc <-  raster("data/psLandCover_mosaic.tif")
st <- states()
tacoma <- places("WA", cb = TRUE) %>%
filter(NAME %in% c("Tacoma","Lakewood","University Place",
"Midland","Federal Way","Clover Creek","Fife")) %>%
st_transform(6580)
wa_outline <- states(cb = TRUE) %>%
filter(NAME == "Washington") %>%
st_transform(6580)
#plot
ggplot() +
geom_sf(data = wa_outline) +
geom_sf(data = tacoma, fill = "red", color = NA) +
theme_void()
locs = st_as_sf(locs_raw,coords=c("longitude","latitude"), crs="+proj=longlat +datum=WGS84")
locs <- st_transform(locs, crs(lc))
locs_NOAA <- st_transform(locs, crs(lcNOAA))
#tacoma2<-st_transform(tacoma, crs(lc))
tacoma2<-st_transform(tacoma, crs(lcNOAA))
bbox <- st_bbox(locs_NOAA)
etacrect <- as(raster::extent(bbox$xmin, bbox$xmax,bbox$ymin, bbox$ymax), "SpatialPolygons")
proj4string(etacrect) <- crs(lcNOAA)
plot(etacrect)
#instead of using tacoma2 shapefile, use tacrect_
lc_tacoma_NOAA<-crop(x = lcNOAA, y = etacrect)
lc_tacoma2_NOAA<-crop(x = lcNOAA, y = tacoma2)
locs_buffer10m = st_buffer(locs, 10)
locs_buffer20m = st_buffer(locs, 20)
locs_buffer30m = st_buffer(locs, 30)
locs_buffer40m = st_buffer(locs, 40)
locs_buffer50m = st_buffer(locs, 50)
locs_buffer100m = st_buffer(locs, 100)
locs_buffer200m = st_buffer(locs, 200)
locs_buffer400m = st_buffer(locs, 400)
locs_buffer800m = st_buffer(locs, 800)
locs_buffer10m$area_sqm <- st_area(locs_buffer10m)#
locs_buffer20m$area_sqm <- st_area(locs_buffer20m)#
locs_buffer30m$area_sqm <- st_area(locs_buffer30m)#
locs_buffer40m$area_sqm <- st_area(locs_buffer40m)#
locs_buffer50m$area_sqm <- st_area(locs_buffer50m)#
locs_buffer100m$area_sqm <- st_area(locs_buffer100m)#
locs_buffer200m$area_sqm <- st_area(locs_buffer200m)#
locs_buffer400m$area_sqm <- st_area(locs_buffer400m)#
locs_buffer800m$area_sqm <- st_area(locs_buffer800m)#
e10 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer10m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e20 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer20m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e30 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer30m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e40 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer40m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e50 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer50m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e100 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer100m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e200 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer200m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e400 <- raster::extract(x = lc_tacoma_NOAA,
y = locs_buffer400m,
df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
e800 <- raster::extract(x = lc_tacoma_NOAA,  y = locs_buffer800m, df = TRUE,method='simple', buffer=NULL, small=FALSE, cellnumbers=FALSE,
na.rm=FALSE, factors=FALSE)
ch4mn_graz<- 132.25# mg CH4 m^-2 d^-1 grazed
ch4sd_graz<- 34.22
ch4mn_ungr<-10.15#mg CH4 m^-2 d^-1 ungrazed
ch4sd_ungr<-2.06
nreps<-20 #replicates per study area
# simulate field data using the means, sds
ch4dat <- as.data.frame(cbind(
c(rep("graz",times=nreps),rep("ungr",times=nreps)),
c(rnorm(n = nreps, mean = ch4mn_graz, sd = ch4sd_graz),
rnorm(n = nreps, mean = ch4mn_ungr, sd = ch4sd_ungr))
))
colnames(ch4dat)<-c("lu","ch4")
ch4dat$ch4<-as.numeric(ch4dat$ch4)
ch4dat$lu<-as.factor(ch4dat$lu)
View(ch4dat)
View(ch4dat)
# convert mg CH4 m^-2 d^-1 to g CH4 ha^-yr
ch4dat$ch4_hayr<-as.numeric(ch4dat$ch4)*0.0365
ch4est<-brm(ch4_hayr~lu, data=ch4dat)
# load packages
library(brms)
ch4est<-brm(ch4_hayr~lu, data=ch4dat)
# check the model
summary(ch4est)
plot(ch4est)
# save the full posterior distribution/samples for later use (i.e. to propagate the estimated uncertainty)
ch4graz_samples <-posterior_samples(ch4est)$b_Intercept
ch4ungr_samples <-posterior_samples(ch4est)$b_Intercept+posterior_samples(ch4est)$b_luungr
as_draws(ch4est)
# Hypothetical project area extent
ext<-30000#ha
ch4emiss_ungr <-ch4ungr_samples*ext*0.001#*0.001 is to convert to kg from g
ch4emiss_graz <-ch4graz_samples*ext*0.001
ch4means<-c(mean(ch4emiss_graz),mean(ch4emiss_ungr))
ch4meds<-c(median(ch4emiss_graz),median(ch4emiss_ungr))
uncert<-cbind(quantile(ch4emiss_graz,c(.10,.90)),
quantile(ch4emiss_ungr,c(.10,.90)))
colnames(uncert)<-c("graz","ungr")
########################################
## Add uncertainty from extent        ##
########################################
ext_sd<-ext/5 #sd=20% of mean extent for noe for now
ext_unc<-rnorm(50,ext,ext_sd)
extmin<-min(ext_unc)
extmax<-max(ext_unc)
#with min estimated extent
ch4emiss_ungr_extmin <-ch4ungr_samples*extmin*0.001#*0.001 is to convert to kg from g
ch4emiss_graz_extmin <-ch4graz_samples*extmin*0.001
ch4means_extmin<-c(mean(ch4emiss_graz_extmin),mean(ch4emiss_ungr_extmin))
ch4meds_extmin<-c(median(ch4emiss_graz_extmin),median(ch4emiss_ungr_extmin))
uncert_extmin<-cbind(quantile(ch4emiss_graz_extmin,c(.10,.90)),
quantile(ch4emiss_ungr_extmin,c(.10,.90)))
colnames(uncert_extmin)<-c("graz","ungr")
#with max est. extent
ch4emiss_ungr_extmax <-ch4ungr_samples*extmax*0.001#*0.001 is to convert to kg from g
ch4emiss_graz_extmax <-ch4graz_samples*extmax*0.001
ch4means_extmax<-c(mean(ch4emiss_graz_extmax),mean(ch4emiss_ungr_extmax))
ch4meds_extmax<-c(median(ch4emiss_graz_extmax),median(ch4emiss_ungr_extmax))
uncert_extmax<-cbind(quantile(ch4emiss_graz_extmax,c(.10,.90)),
quantile(ch4emiss_ungr_extmax,c(.10,.90)))
colnames(uncert_extmax)<-c("graz","ungr")
x<-c(1,2)
plot(x,ch4meds,
type="p", pch=16, cex=1,col="darkgreen",
ylim=c(-1,250),xlim=c(.5,2.5),xaxt='n',cex.axis=2,
ylab="CH4 (kg per ha per yr)",xlab="Land Use",cex.lab=2,
main="CH4 Emissions in Project Area",
bty="l")
for(i in 1:length(x)){
arrows(x[i],uncert[1,i],x[i],uncert[2,i],
code=3, angle=90, length=0.05,lwd=2, col="darkgreen")
}
for(i in 1:length(x)){
arrows(x[i],uncert_extmin[1,i],x[i],uncert_extmax[2,i],
code=3, angle=90, length=0.05,lwd=2, col="lightgreen")
}
axis(1,at=x,labels=c("grazed","ungrazed"), cex.axis=2)
points(x,ch4meds,pch=16, cex=2.5,col="darkgreen",)
legend("topright",lty=1,lwd=3,col=c(,"darkgreen","lightgreen"), legend=c("Flux uncertainty","Area uncertainty"))
legend("topright",lty=1,lwd=3,col=c("darkgreen","lightgreen"), legend=c("Flux uncertainty","Area uncertainty"), bty="n")
plot(x,ch4meds,
type="p", pch=16, cex=1,col="darkgreen",
ylim=c(-1,250),xlim=c(.5,2.5),xaxt='n',cex.axis=2,
ylab="CH4 (kg per ha per yr)",xlab="Land Use",cex.lab=2,
main="CH4 Emissions in Project Area",
bty="l")
for(i in 1:length(x)){
arrows(x[i],uncert[1,i],x[i],uncert[2,i],
code=3, angle=90, length=0.05,lwd=2, col="darkgreen")
}
for(i in 1:length(x)){
arrows(x[i],uncert_extmin[1,i],x[i],uncert_extmax[2,i],
code=3, angle=90, length=0.05,lwd=2, col="lightgreen")
}
axis(1,at=x,labels=c("grazed","ungrazed"), cex.axis=2)
points(x,ch4meds,pch=16, cex=2.5,col="darkgreen",)
legend("topright",lty=1,lwd=3,col=c("darkgreen","lightgreen"), legend=c("Flux uncertainty","Area uncertainty"), bty="n")
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
getwd()
setwd("~/GitHub/bayes4cons"
)
png("figs/ncs/ncsprojimpactch4.png",height=600,width=800)
plot(x,ch4meds,
type="p", pch=16, cex=1,col="darkgreen",
ylim=c(-1,250),xlim=c(.5,2.5),xaxt='n',cex.axis=2,
ylab="CH4 (kg per ha per yr)",xlab="Land Use",cex.lab=2,
main="CH4 Emissions in Project Area",
bty="l")
for(i in 1:length(x)){
arrows(x[i],uncert[1,i],x[i],uncert[2,i],
code=3, angle=90, length=0.05,lwd=2, col="darkgreen")
}
for(i in 1:length(x)){
arrows(x[i],uncert_extmin[1,i],x[i],uncert_extmax[2,i],
code=3, angle=90, length=0.05,lwd=2, col="lightgreen")
}
axis(1,at=x,labels=c("grazed","ungrazed"), cex.axis=2)
points(x,ch4meds,pch=16, cex=2.5,col="darkgreen",)
legend("topright",lty=1,lwd=3,col=c("darkgreen","lightgreen"), legend=c("Flux uncertainty","Area uncertainty"), bty="n")
dev.off()
install.packages("rstan")
knitr::opts_chunk$set(echo = TRUE)
sessionInfo()
exp(-7)
exp(7)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(bayesplot)
library(ggplot2)
# To run in parallel on multiple cores
options(mc.cores=parallel::detectCores())
# To avoid recompiling unchanged Stan program
rstan_options(auto_write=TRUE)
# Create a vector that will keep track of the states
# It's of length T + 1 (+1 for t=0)
TT <- 20
z <- numeric(TT + 1)
# Population starts at 20 (number of individual re-introduced)
z[1] <- 20
# Standard deviation of the process variation
sdo <- 10
sdp <- 0.05
beta0 <- log(1.3)
beta1 <- -0.005
# Set the seed, so we can reproduce the results
set.seed(87687)
# For-loop that simulates the state through time, using i instead of t,
for(i in 1:TT){
# This is the process equation
z[i+1] <- z[i]*exp(beta0 + beta1*z[i] + rnorm(1, 0, sdp))
# Note that this index is shifted compared to equation in text,
# because we assume the first value to be at time 0
}
# Create a vector that will keep track of the observations
# It's of length T
y <- numeric(TT)
# Standard deviation of the observation error
# For t=1, ... T, add measurement error
# Remember that z[1] is t=0
y <- z[2:(TT+1)] + rnorm(TT, 0, sdo)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col="hotpink") +
geom_point(data = monitoring, aes(y= obs, x = year), col="grey") +
ylab("Population")
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col="hotpink") +
geom_point(data = monitoring, aes(y= obs, x = year), col="grey") +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col="hotpink") +
geom_point(data = monitoring, aes(y= obs, x = year), col=grey(0.1)) +
ylab("Population/count") +
theme_bw()
# Colours for plots
col_ts <- c("hotpink", grey(0.2)) # Real pop. traj, observed pop. traj.
# Colours for plots
col_real <- "hotpink" # Real population trajectory
col_obs <- grey(0.2) # Observed population trajectory
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), col = "real") +
geom_point(data = monitoring, aes(y= obs, x = year), col = "obs") +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), colour = "real") +
geom_point(data = monitoring, aes(y= obs, x = year), colour = "obs") +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year), colour = "real") +
geom_point(data = monitoring, aes(y= obs, x = year), colour = "obs") +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year, colour = "real")) +
geom_point(data = monitoring, aes(y= obs, x = year, colour = "obs")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year, colour = "real")) +
geom_point(data = monitoring, aes(y= obs, x = year, colour = "obs")) +
scale_color_manual(name = "Pop. trajctories",
values = c("real" = col_real, "obs" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y= true, x=year, colour = "Real")) +
geom_point(data = monitoring, aes(y= obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(bayesplot)
library(ggplot2)
# To run in parallel on multiple cores
options(mc.cores=parallel::detectCores())
# To avoid recompiling unchanged Stan program
rstan_options(auto_write=TRUE)
# Colours for plots
col_real <- "hotpink" # Real population trajectory
col_obs <- grey(0.2) # Observed population trajectory
# Create a vector that will keep track of the states
# It's of length T + 1 (+1 for t=0)
TT <- 20
z <- numeric(TT + 1)
# Population starts at 20 (number of individual re-introduced)
z[1] <- 20
# Standard deviation of the process variation
sdo <- 10
sdp <- 0.05
beta0 <- log(1.3)
beta1 <- -0.005
# Set the seed, so we can reproduce the results
set.seed(87687)
# For-loop that simulates the state through time, using i instead of t,
for(i in 1:TT){
# This is the process equation
z[i+1] <- z[i]*exp(beta0 + beta1*z[i] + rnorm(1, 0, sdp))
# Note that this index is shifted compared to equation in text,
# because we assume the first value to be at time 0
}
# Create a vector that will keep track of the observations
# It's of length T
y <- numeric(TT)
# Standard deviation of the observation error
# For t=1, ... T, add measurement error
# Remember that z[1] is t=0
y <- z[2:(TT+1)] + rnorm(TT, 0, sdo)
monitoring <- data.frame(year = seq(2024-TT, length.out = TT), true = z[-1], obs = y)
ggplot() +
geom_point(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_point(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
geom_line(data = monitoring, aes(y = true, x = year, colour = "Real")) +
geom_line(data = monitoring, aes(y = obs, x = year, colour = "Observed")) +
scale_color_manual(name = "Pop. trajctories",
values = c("Real" = col_real, "Observed" = col_obs)) +
ylab("Population/count") +
theme_bw()
dataStan <- list(y=y, TT=TT, w0=log(z[1]))
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
m.vague <- stan(file = "ssm_dens_vague.stan",
data = dataStan,
chains = 3, iter = 50000, seed="123")
exp(0.05)
exp(0.07)
exp(-0.05)
z[1]
dataStan <- list(y = y, TT = TT,
w0 = log(z[1]), # Starting population, 20 (number re-introduce)
sd0 = 0.0001) # Low sd for the first time step
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
exp(log(0.05))
exp(-log(0.05))
exp(log(-0.05))
exp(log(0.05))
exp(0.05)
exp(-0.05)
exp(-0.10)
exp(0.10)
exp(0.25)
exp(-0.25)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
control=list(adapt_delta=0.9)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
pairs()
pairs(m.biol.informed)
control=list(adapt_delta = 0.99)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 50000, seed= "123")
control=list(adapt_delta = 0.99)
m.biol.informed <- stan(file = "ssm_dens_biol_informed.stan",
data = dataStan,
chains = 3, iter = 100000, seed= "123")
